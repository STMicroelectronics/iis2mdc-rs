#![no_std]
#![doc = include_str!("../README.md")]

use crate::prelude::*;
use core::fmt::Debug;
use embedded_hal::delay::DelayNs;
use embedded_hal::i2c::{I2c, SevenBitAddress};
use embedded_hal::spi::SpiDevice;
use st_mems_bus::BusOperation;

pub mod prelude;
pub mod register;

/// The Iis2mdc generic driver struct.
pub struct Iis2mdc<B, T> {
    /// The bus driver.
    pub bus: B,
    pub tim: T,
}

/// Driver errors.
#[derive(Debug)]
pub enum Error<B> {
    /// An error occurred at the bus level. Any methods that access the I2C/SPI bus to interact
    /// with the sensor may return this error if the bus operation fails.
    ///
    /// The generic type B represents the specific error generated by the HAL of the microcontroller in use.
    Bus(B),
}

impl<P, T> Iis2mdc<st_mems_bus::i2c::I2cBus<P>, T>
where
    P: I2c,
    T: DelayNs,
{
    /// Constructor method for using the I2C bus.
    ///
    /// # Arguments
    ///
    /// * `i2c`: The I2C peripheral.
    /// * `address`: The I2C address of the COMPONENT sensor.
    /// * `tim`: The timer of the COMPONENT sensor.
    ///
    /// # Returns
    ///
    /// * `Self`: Returns an instance of `Iis2mdc`.
    pub fn new_i2c(i2c: P, address: I2CAddress, tim: T) -> Self {
        // Initialize the I2C bus with the COMPONENT address
        let bus = st_mems_bus::i2c::I2cBus::new(i2c, address as SevenBitAddress);
        Self { bus, tim }
    }
}
impl<B, T> Iis2mdc<B, T>
where
    B: BusOperation,
    T: DelayNs,
{
    /// Create a safe fake buffer to use the sensor as master of the
    /// sensor hub.
    ///
    /// # Arguments
    ///
    /// * `bus`: The bus that implements BusOperation.
    /// * `tim`: The timer of the COMPONENT sensor.
    /// * `slave_address`: The I2C address of the slave sensor
    ///
    /// # Returns
    ///
    /// * `Self`: Returns an instance of `Iis2mdc`.
    pub fn from_bus(bus: B, tim: T) -> Self {
        Self { bus, tim }
    }
}

impl<P, T> Iis2mdc<st_mems_bus::spi::SpiBus<P>, T>
where
    P: SpiDevice,
    T: DelayNs,
{
    /// Constructor method for using the SPI bus.
    ///
    /// # Arguments
    ///
    /// * `spi`: The SPI peripheral.
    /// * `tim`: The timer of the COMPONENT sensor.
    ///
    /// # Returns
    ///
    /// * `Result`
    ///     * `Self`: Returns an instance of `Iis2mdc`.
    ///     * `Err`: Returns an error if the initialization fails.
    pub fn new_spi(spi: P, tim: T) -> Self {
        // Initialize the SPI bus
        let bus = st_mems_bus::spi::SpiBus::new(spi);
        Self { bus, tim }
    }
}

impl<B: BusOperation, T: DelayNs> Iis2mdc<B, T> {
    pub fn read_from_register(&mut self, reg: u8, buf: &mut [u8]) -> Result<(), Error<B::Error>> {
        self.bus.read_from_register(reg, buf).map_err(Error::Bus)
    }

    pub fn write_to_register(&mut self, reg: u8, buf: &[u8]) -> Result<(), Error<B::Error>> {
        self.bus.write_to_register(reg, buf).map_err(Error::Bus)
    }

    /// Sets the magnetic sensor's hard-iron offset to compensate for environmental effects.
    ///
    /// This function writes a set of three 16-bit values to the sensor's registers, which represent
    /// the hard-iron offset. These offsets are used to adjust the magnetic output data, effectively
    /// removing environmental biases. The data format for these values is two's complement, with
    /// a resolution of 1LSb = 1.5mG.
    ///
    /// # Arguments
    ///
    /// * `val`: A reference to an array containing three 16-bit integers. Each integer represents
    ///   the offset for one axis (X, Y, Z) of the magnetic sensor. The values are expected to be
    ///   in two's complement format.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the offsets are successfully written
    ///   to the sensor's registers. If the operation fails, it returns an `Err` containing the
    ///   specific error type generated by the microcontroller's HAL.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation
    pub fn mag_user_offset_set(&mut self, val: &[i16; 3]) -> Result<(), Error<B::Error>> {
        OffsetXYZ {
            x: val[0],
            y: val[1],
            z: val[2],
        }
        .write(self)
    }

    /// Retrieves the magnetic sensor's hard-iron offset values.
    ///
    /// This function reads a set of three 16-bit values from the sensor's registers, which represent
    /// the hard-iron offset. These offsets are used to adjust the magnetic output data, effectively
    /// removing environmental biases. The data format for these values is two's complement, with
    /// a resolution of 1LSb = 1.5mG.
    ///
    /// # Returns
    ///
    /// * `Result<[i16; 3], Error<B::Error>>`: Returns an array of three 16-bit integers if the
    ///   offsets are successfully read from the sensor's registers. Each integer represents the
    ///   offset for one axis (X, Y, Z) of the magnetic sensor.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation
    pub fn mag_user_offset_get(&mut self) -> Result<[i16; 3], Error<B::Error>> {
        let val = OffsetXYZ::read(self)?;
        Ok([val.x, val.y, val.z])
    }

    /// Sets the operating mode of the sensor.
    ///
    /// This function modifies the operating mode by updating the `md` field in the `CFG_REG_A` register.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired operating mode, represented by the `Md` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the mode is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn operating_mode_set(&mut self, val: Md) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegA::read(self)?;
        reg.set_md(val as u8);
        reg.write(self)
    }

    /// Retrieves the current operating mode of the sensor.
    ///
    /// This function reads the `md` field from the `CFG_REG_A` register to determine the current operating mode.
    ///
    /// # Returns
    ///
    /// * `Result<Md, Error<B::Error>>`: Returns the current operating mode as an `Md` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn operating_mode_get(&mut self) -> Result<Md, Error<B::Error>> {
        let val = CfgRegA::read(self)?.md();
        Ok(Md::try_from(val).unwrap_or_default())
    }

    /// Sets the output data rate of the sensor.
    ///
    /// This function modifies the output data rate by updating the `odr` field in the `CFG_REG_A` register.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired data rate, represented by the `Odr` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the data rate is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn data_rate_set(&mut self, val: Odr) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegA::read(self)?;
        reg.set_odr(val as u8);
        reg.write(self)
    }

    /// Retrieves the current output data rate of the sensor.
    ///
    /// This function reads the `odr` field from the `CFG_REG_A` register to determine the current data rate.
    ///
    /// # Returns
    ///
    /// * `Result<Odr, Error<B::Error>>`: Returns the current data rate as an `Odr` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn data_rate_get(&mut self) -> Result<Odr, Error<B::Error>> {
        let val = CfgRegA::read(self)?.odr();
        Ok(Odr::try_from(val).unwrap_or_default())
    }

    /// Sets the power mode of the sensor to high-resolution or low-power.
    ///
    /// This function modifies the power mode by updating the `lp` field in the `CFG_REG_A` register.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired power mode, represented by the `Lp` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the power mode is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn power_mode_set(&mut self, val: Lp) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegA::read(self)?;
        reg.set_lp(val as u8);
        reg.write(self)
    }

    /// Retrieves the current power mode of the sensor.
    ///
    /// This function reads the `lp` field from the `CFG_REG_A` register to determine the current power mode.
    ///
    /// # Returns
    ///
    /// * `Result<Lp, Error<B::Error>>`: Returns the current power mode as an `Lp` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn power_mode_get(&mut self) -> Result<Lp, Error<B::Error>> {
        let val = CfgRegA::read(self)?.lp();
        Ok(Lp::try_from(val).unwrap_or_default())
    }

    /// Enables or disables the magnetometer temperature compensation.
    ///
    /// This function modifies the temperature compensation setting by updating the `comp_temp_en` field in the `CFG_REG_A` register.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired state of temperature compensation (enabled or disabled).
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the setting is successfully updated. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn offset_temp_comp_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegA::read(self)?;
        reg.set_comp_temp_en(val);
        reg.write(self)
    }

    /// Retrieves the current state of the magnetometer temperature compensation.
    ///
    /// This function reads the `comp_temp_en` field from the `CFG_REG_A` register to determine if temperature compensation is enabled or disabled.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current state of temperature compensation. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn offset_temp_comp_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegA::read(self)?.comp_temp_en())
    }

    /// Sets the low-pass filter bandwidth of the sensor.
    ///
    /// This function modifies the low-pass filter bandwidth by updating the `lpf` field in the `CFG_REG_B` register.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired low-pass filter bandwidth, represented by the `Lpf` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the bandwidth is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn low_pass_bandwidth_set(&mut self, val: Lpf) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegB::read(self)?;
        reg.set_lpf(val as u8);
        reg.write(self)
    }

    /// Retrieves the current low-pass filter bandwidth of the sensor.
    ///
    /// This function reads the `lpf` field from the `CFG_REG_B` register to determine the current bandwidth setting.
    ///
    /// # Returns
    ///
    /// * `Result<Lpf, Error<B::Error>>`: Returns the current low-pass filter bandwidth as an `Lpf` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn low_pass_bandwidth_get(&mut self) -> Result<Lpf, Error<B::Error>> {
        let val = CfgRegB::read(self)?.lpf();
        Ok(Lpf::try_from(val).unwrap_or_default())
    }

    /// Sets the reset pulse mode.
    ///
    /// This function modifies the reset pulse mode by updating the `set_rst` field in the `CFG_REG_B` register.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired reset pulse mode, represented by the `SetRst` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the mode is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn set_rst_mode_set(&mut self, val: SetRst) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegB::read(self)?;
        reg.set_set_rst(val as u8);
        reg.write(self)
    }

    /// Retrieves the current reset pulse mode.
    ///
    /// This function reads the `set_rst` field from the `CFG_REG_B` register to determine the current reset pulse mode.
    ///
    /// # Returns
    ///
    /// * `Result<SetRst, Error<B::Error>>`: Returns the current reset pulse mode as a `SetRst` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn set_rst_mode_get(&mut self) -> Result<SetRst, Error<B::Error>> {
        let val = CfgRegB::read(self)?.set_rst();
        Ok(SetRst::try_from(val).unwrap_or_default())
    }

    /// Enables offset cancellation in single measurement mode.
    ///
    /// This function modifies the offset cancellation setting by updating the `off_canc_one_shot` field in the `CFG_REG_B` register.
    /// The `OFF_CANC` bit must be set to 1, which requires calling the function `set_rst_mode(SensOffCancEveryOdr)`.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired state of offset cancellation (enabled or disabled).
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the setting is successfully updated. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn off_canc_en_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegB::read(self)?;
        reg.set_off_canc_one_shot(val);
        reg.write(self)
    }

    /// Retrieves the current state of offset cancellation in single measurement mode.
    ///
    /// This function reads the `off_canc_one_shot` field from the `CFG_REG_B` register to determine if offset cancellation is enabled or disabled.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current state of offset cancellation. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn off_canc_en_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegB::read(self)?.off_canc_one_shot())
    }

    /// Sets the block data update mode.
    ///
    /// This function modifies the block data update setting by updating the `bdu` field in the `CFG_REG_C` register.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired state of block data update (enabled or disabled).
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the setting is successfully updated. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn block_data_update_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegC::read(self)?;
        reg.set_bdu(val);
        reg.write(self)
    }

    /// Retrieves the current block data update mode.
    ///
    /// This function reads the `bdu` field from the `CFG_REG_C` register to determine if block data update is enabled or disabled.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current state of block data update. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn block_data_update_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegC::read(self)?.bdu())
    }

    /// Checks if magnetic data is ready.
    ///
    /// This function reads the `zyxda` field from the `STATUS_REG` register to determine if a new set of magnetic data is available.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the state indicating if magnetic data is ready. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn mag_data_ready_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(StatusReg::read(self)?.zyxda())
    }

    /// Checks if magnetic data has overrun.
    ///
    /// This function reads the `zyxor` field from the `STATUS_REG` register to determine if magnetic data has overrun.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the state indicating if magnetic data has overrun. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn mag_data_ovr_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(StatusReg::read(self)?.zyxor())
    }

    // Retrieves the raw magnetic output values.
    ///
    /// This function reads the magnetic output values from the sensor's registers, returning them as a three-element array of 16-bit integers.
    ///
    /// # Returns
    ///
    /// * `Result<[i16; 3], Error<B::Error>>`: Returns an array containing the raw magnetic output values. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn magnetic_raw_get(&mut self) -> Result<[i16; 3], Error<B::Error>> {
        let val = OutXYZ::read(self)?;
        Ok([val.x, val.y, val.z])
    }

    //// Retrieves the raw temperature output value.
    ///
    /// This function reads the temperature value from the sensor's registers, returning it as a 16-bit integer.
    ///
    /// # Returns
    ///
    /// * `Result<i16, Error<B::Error>>`: Returns the raw temperature value. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn temperature_raw_get(&mut self) -> Result<i16, Error<B::Error>> {
        Ok(TempOutReg::read(self)?.temp_out())
    }

    /// Retrieves the device ID.
    ///
    /// This function reads the device ID from the sensor's registers, returning it as an 8-bit integer.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the device ID. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn device_id_get(&mut self) -> Result<u8, Error<B::Error>> {
        let mut buff: [u8; 1] = [0];
        self.read_from_register(Reg::WhoAmI as u8, &mut buff)?;

        Ok(buff[0])
    }

    /// Performs a software reset, restoring default values in user registers.
    ///
    /// This function modifies the `soft_rst` field in the `CFG_REG_A` register to initiate a software reset.
    ///
    /// # Arguments
    ///
    /// * `val`: The value to set for the software reset.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the reset is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn reset_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegA::read(self)?;
        reg.set_soft_rst(val);
        reg.write(self)
    }

    /// Retrieves the current software reset state.
    ///
    /// This function reads the `soft_rst` field from the `CFG_REG_A` register to determine the current reset state.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current software reset state. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn reset_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegA::read(self)?.soft_rst())
    }

    /// Reboots memory content, reloading calibration parameters.
    ///
    /// This function modifies the `reboot` field in the `CFG_REG_A` register to initiate a memory reboot.
    ///
    /// # Arguments
    ///
    /// * `val`: The value to set for the memory reboot.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the reboot is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn boot_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegA::read(self)?;
        reg.set_reboot(val);
        reg.write(self)
    }

    /// Retrieves the current memory reboot state.
    ///
    /// This function reads the `reboot` field from the `CFG_REG_A` register to determine the current reboot state.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current memory reboot state. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn boot_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegA::read(self)?.reboot())
    }

    /// Sets the self-test mode.
    ///
    /// This function modifies the `self_test` field in the `CFG_REG_C` register to initiate a self-test.
    ///
    /// # Arguments
    ///
    /// * `val`: The value to set for the self-test mode.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the self-test mode is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn self_test_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegC::read(self)?;
        reg.set_self_test(val);
        reg.write(self)
    }

    /// Retrieves the current self-test mode.
    ///
    /// This function reads the `self_test` field from the `CFG_REG_C` register to determine the current self-test mode.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current self-test mode. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn self_test_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegC::read(self)?.self_test())
    }

    /// Sets the data format to Big or Little Endian.
    ///
    /// This function modifies the `ble` field in the `CFG_REG_C` register to select the data format.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired data format, represented by the `Ble` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the data format is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn data_format_set(&mut self, val: Ble) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegC::read(self)?;
        reg.set_ble(val as u8);
        reg.write(self)
    }

    /// Retrieves the current data format (Big or Little Endian).
    ///
    /// This function reads the `ble` field from the `CFG_REG_C` register to determine the current data format.
    ///
    /// # Returns
    ///
    /// * `Result<Ble, Error<B::Error>>`: Returns the current data format as a `Ble` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn data_format_get(&mut self) -> Result<Ble, Error<B::Error>> {
        let val = CfgRegC::read(self)?.ble();
        Ok(Ble::try_from(val).unwrap_or_default())
    }

    /// Retrieves the device status information.
    ///
    /// This function reads the `STATUS_REG` register to obtain the current status of the device.
    ///
    /// # Returns
    ///
    /// * `Result<StatusReg, Error<B::Error>>`: Returns the status register value. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn status_get(&mut self) -> Result<StatusReg, Error<B::Error>> {
        StatusReg::read(self)
    }

    /// Configures the interrupt block recognition for data checks after/before hard-iron correction.
    ///
    /// This function modifies the `int_on_dataoff` field in the `CFG_REG_B` register to set the interrupt configuration.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired interrupt configuration, represented by the `IntOnDataOff` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the configuration is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn offset_int_conf_set(&mut self, val: IntOnDataOff) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegB::read(self)?;
        reg.set_int_on_dataoff(val as u8);
        reg.write(self)
    }

    /// Retrieves the current interrupt configuration for data checks after/before hard-iron correction.
    ///
    /// This function reads the `int_on_dataoff` field from the `CFG_REG_B` register to determine the current configuration.
    ///
    /// # Returns
    ///
    /// * `Result<IntOnDataOff, Error<B::Error>>`: Returns the current interrupt configuration as an `IntOnDataOff` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn offset_int_conf_get(&mut self) -> Result<IntOnDataOff, Error<B::Error>> {
        let val = CfgRegB::read(self)?.int_on_dataoff();
        Ok(IntOnDataOff::try_from(val).unwrap_or_default())
    }

    /// Sets the data-ready signal on the INT_DRDY pin.
    ///
    /// This function modifies the `drdy_on_pin` field in the `CFG_REG_C` register to enable or disable the data-ready signal.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired state of the data-ready signal (enabled or disabled).
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the signal is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn drdy_on_pin_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegC::read(self)?;
        reg.set_drdy_on_pin(val);
        reg.write(self)
    }

    /// Retrieves the current state of the data-ready signal on the INT_DRDY pin.
    ///
    /// This function reads the `drdy_on_pin` field from the `CFG_REG_C` register to determine if the data-ready signal is enabled or disabled.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current state of the data-ready signal. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn drdy_on_pin_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegC::read(self)?.drdy_on_pin())
    }

    /// Sets the interrupt signal on the INT_DRDY pin.
    ///
    /// This function modifies the `int_on_pin` field in the `CFG_REG_C` register to enable or disable the interrupt signal.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired state of the interrupt signal (enabled or disabled).
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the signal is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn int_on_pin_set(&mut self, val: u8) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegC::read(self)?;
        reg.set_int_on_pin(val);
        reg.write(self)
    }

    /// Retrieves the current state of the interrupt signal on the INT_DRDY pin.
    ///
    /// This function reads the `int_on_pin` field from the `CFG_REG_C` register to determine if the interrupt signal is enabled or disabled.
    ///
    /// # Returns
    ///
    /// * `Result<u8, Error<B::Error>>`: Returns the current state of the interrupt signal. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn int_on_pin_get(&mut self) -> Result<u8, Error<B::Error>> {
        Ok(CfgRegC::read(self)?.int_on_pin())
    }

    /// Sets the interrupt generator configuration.
    ///
    /// This function writes to the `INT_CTRL_REG` register to configure the interrupt generator settings.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired configuration for the interrupt generator, represented by the `IntCtrlReg` struct.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the configuration is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn int_gen_conf_set(&mut self, val: IntCtrlReg) -> Result<(), Error<B::Error>> {
        val.write(self)
    }

    /// Retrieves the current interrupt generator configuration.
    ///
    /// This function reads the `INT_CTRL_REG` register to obtain the current configuration of the interrupt generator.
    ///
    /// # Returns
    ///
    /// * `Result<IntCtrlReg, Error<B::Error>>`: Returns the current configuration as an `IntCtrlReg` struct. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn int_gen_conf_get(&mut self) -> Result<IntCtrlReg, Error<B::Error>> {
        IntCtrlReg::read(self)
    }

    /// Retrieves the interrupt generator source register value.
    ///
    /// This function reads the `INT_SOURCE_REG` register to obtain the source of the interrupt generator.
    ///
    /// # Returns
    ///
    /// * `Result<IntSourceReg, Error<B::Error>>`: Returns the source register value as an `IntSourceReg` struct. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn int_gen_source_get(&mut self) -> Result<IntSourceReg, Error<B::Error>> {
        IntSourceReg::read(self)
    }

    /// Sets the user-defined threshold value for the XL interrupt event on the generator.
    ///
    /// This function writes the threshold value to the `INT_THS_L_REG` register. The data format is two's complement with 1LSb = 1.5mG.
    ///
    /// # Arguments
    ///
    /// * `val`: The threshold value to set, represented as a 16-bit integer.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the threshold is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation..
    pub fn int_gen_threshold_set(&mut self, val: i16) -> Result<(), Error<B::Error>> {
        IntThsReg::from_bits(val.cast_unsigned()).write(self)
    }

    /// Retrieves the user-defined threshold value for the XL interrupt event on the generator.
    ///
    /// This function reads the threshold value from the `INT_THS_L_REG` register. The data format is two's complement with 1LSb = 1.5mG.
    ///
    /// # Returns
    ///
    /// * `Result<i16, Error<B::Error>>`: Returns the threshold value as a 16-bit integer. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn int_gen_threshold_get(&mut self) -> Result<i16, Error<B::Error>> {
        Ok(IntThsReg::read(self)?.int_ths())
    }

    /// Enables or disables the I2C interface.
    ///
    /// This function modifies the `i2c_dis` field in the `CFG_REG_C` register to enable or disable the I2C interface.
    ///
    /// # Arguments
    ///
    /// * `val`: The desired state of the I2C interface, represented by the `I2cDis` enum.
    ///
    /// # Returns
    ///
    /// * `Result<(), Error<B::Error>>`: Returns `Ok(())` if the interface is successfully set. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn i2c_interface_set(&mut self, val: I2cDis) -> Result<(), Error<B::Error>> {
        let mut reg = CfgRegC::read(self)?;
        reg.set_i2c_dis(val as u8);
        reg.write(self)
    }

    /// Retrieves the current state of the I2C interface.
    ///
    /// This function reads the `i2c_dis` field from the `CFG_REG_C` register to determine if the I2C interface is enabled or disabled.
    ///
    /// # Returns
    ///
    /// * `Result<I2cDis, Error<B::Error>>`: Returns the current state of the I2C interface as an `I2cDis` enum. Returns an `Err` if the operation fails.
    ///
    /// # Errors
    ///
    /// - `Error::Bus(B::Error)`: This error is returned if there is a failure in the bus operation.
    pub fn i2c_interface_get(&mut self) -> Result<I2cDis, Error<B::Error>> {
        let val = CfgRegC::read(self)?.i2c_dis();
        Ok(I2cDis::try_from(val).unwrap_or_default())
    }
}

/// Converts LSB value to milligauss.
pub fn from_lsb_to_mgauss(lsb: i16) -> f32 {
    lsb as f32 * 1.5
}

/// Converts LSB to Celsius.
pub fn from_lsb_to_celsius(lsb: i16) -> f32 {
    (lsb as f32 / 8.0) + 25.0
}

/// Represents the I2C address for the device.
#[repr(u8)]
#[derive(Clone, Copy, PartialEq)]
pub enum I2CAddress {
    /// The I2C address for the device, set to `0x1e`.
    I2cAdd = 0x1e,
}

/// Device Who am I
pub const IIS2MDC_ID: u8 = 0x40;
